RUG_LOG_FILE = "/home/ubuntu/nyx/runtime/data/rug_events.json"

RUG_LIMIT = 2
RUG_WINDOW_MINUTES = 5
MANUAL_STOP_DURATION_MINUTES = 10

RUG_TIME_WINDOW_MINUTES = 120  # How far back to look for rugs
RUG_THRESHOLD = 5              # How many recent rugs = danger
REPUTATION_RISK_WEIGHT = 3.0   # How much to penalize bad wallets

_stop_snipe_mode = False
_stop_snipe_start_time = None

# === File-Based Snipe Block ===

def _load_block_data():
    if not os.path.exists(BLOCK_FILE):
        return {}
    with open(BLOCK_FILE, "r") as f:
        return json.load(f)

def get_rug_rate(token_context: dict) -> dict:
    """
    Calculates an estimated rug rate for the current token context.
    Considers recent failed trades and suspicious wallet reputation.
    """
    token_address = token_context.get("token_address")
    creator = token_context.get("creator")

    rugs = get_recent_failed_trades(since_minutes=RUG_TIME_WINDOW_MINUTES)
    rug_count = len(rugs)
    risk_score = 0
    reasons = []

    if rug_count >= RUG_THRESHOLD:
        risk_score += 5
        reasons.append(f"{rug_count} rugs in past {RUG_TIME_WINDOW_MINUTES}m")

    if creator:
        creator_rug_score = get_wallet_rug_score(creator)
        if creator_rug_score >= REPUTATION_RISK_WEIGHT:
            risk_score += creator_rug_score
            reasons.append(f"creator rug rep: {creator_rug_score:.1f}")

    risk_score = min(risk_score, 10)

    return {
        "rug_rate": rug_count,
        "risk_score": risk_score,
        "reasons": reasons,
    }

def _save_block_data(data):
    with open(BLOCK_FILE, "w") as f:
        json.dump(data, f)

def block_snipe_for(duration_minutes: int, reason: str = "Manual override"):
    until = (datetime.utcnow() + timedelta(minutes=duration_minutes)).isoformat()
    data = {"blocked_until": until, "reason": reason}
    _save_block_data(data)
    log_event(f"🚫 Snipe blocked for {duration_minutes} minutes. Reason: {reason}")

def unblock_snipe():
    if os.path.exists(BLOCK_FILE):
        os.remove(BLOCK_FILE)
        log_event("✅ Snipe block removed manually.")

def is_file_blocked() -> bool:
    data = _load_block_data()
    if not data.get("blocked_until"):
        return False
    try:
        blocked_until = datetime.fromisoformat(data["blocked_until"])
        return datetime.utcnow() < blocked_until
    except Exception:
        return False

def get_block_reason() -> str:
    data = _load_block_data()
    return data.get("reason", "Unknown") if is_file_blocked() else "Not blocked"

# === Rug-Wave Defender ===

def _load_rug_events():
    if not os.path.exists(RUG_LOG_FILE):
        return []
    with open(RUG_LOG_FILE, "r") as f:
        return json.load(f)

def _save_rug_events(events):
    with open(RUG_LOG_FILE, "w") as f:
        json.dump([e.isoformat() if isinstance(e, datetime) else e for e in events], f)

def register_rug_event(token_address: str = None):
    now = datetime.utcnow()
    events = _load_rug_events()
    events.append(now.isoformat())
    recent = [
        datetime.fromisoformat(e)
        for e in events
        if (now - datetime.fromisoformat(e)).total_seconds() <= RUG_WINDOW_MINUTES * 60
    ]
    _save_rug_events(recent)

    # 🧠 Auto-learn new rug pattern
    if token_address:
        try:
            asyncio.create_task(save_new_rug_pattern(token_address, fetch_contract_bytecode))
        except Exception as e:
            log_event(f"⚠️ Failed to save rug pattern for {token_address}: {e}")

    if len(recent) >= RUG_LIMIT:
        block_snipe_for(RUG_WINDOW_MINUTES, reason="Rug wave detected")

# === Stop-Snipe Logic ===

def is_snipe_blocked() -> bool:
    _check_manual_reset()
    return _stop_snipe_mode or is_file_blocked() or not config.get("use_stop_snipe", True)

def is_stop_snipe_mode() -> bool:
    return is_snipe_blocked()

def toggle_stop_snipe_mode():
    global _stop_snipe_mode, _stop_snipe_start_time
    _stop_snipe_mode = not _stop_snipe_mode
    _stop_snipe_start_time = datetime.utcnow() if _stop_snipe_mode else None
    state = "ENABLED" if _stop_snipe_mode else "DISABLED"
    log_event(f"🛑 Stop-snipe mode manually toggled: {state}")
    return _stop_snipe_mode

def _check_manual_reset():
    global _stop_snipe_mode, _stop_snipe_start_time
    if _stop_snipe_mode and _stop_snipe_start_time:
        elapsed = (datetime.utcnow() - _stop_snipe_start_time).total_seconds()
        if elapsed >= MANUAL_STOP_DURATION_MINUTES * 60:
            _stop_snipe_mode = False
            _stop_snipe_start_time = None
            log_event("🕒 Manual stop-snipe timer expired. Auto-resuming.")

# === AI/External Trigger ===

def activate_stop_snipes(reason: str = "Triggered by AI"):
    block_snipe_for(MANUAL_STOP_DURATION_MINUTES, reason=reason)
    log_event(f"🤖 Auto stop-snipes activated. Reason: {reason}")
